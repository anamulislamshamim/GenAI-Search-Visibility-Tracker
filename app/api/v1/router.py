from fastapi import APIRouter, Depends, HTTPException, status, Path
from app.core.models import BrandQuery, QueryResponse, QueryRecord, AggregateMetrics, QueryDetails
from app.services.llm_selector import get_llm_service
from app.services.llm_base import LLMBase
from app.db.mongodb.storage import insert_query_record
import datetime
import asyncio
from app.analysis.nlp_pipeline import start_analysis_pipeline
from app.db.mongodb.storage import insert_query_record, get_query_details_by_id
from app.db.postgres.storage import get_brand_metrics


router = APIRouter()

@router.post("/query-brand", response_model=QueryResponse, status_code=status.HTTP_202_ACCEPTED)
async def query_brand(
    query: BrandQuery,
    llm_service: LLMBase = Depends(get_llm_service) # Dependency Injection
):
    """
    1. Queries the selected GenAI model about a brand.
    2. Stores the raw response in MongoDB.
    3. Triggers the asynchronous processing pipeline (ES indexing, score calculation).
    """
    brand_name = query.brand_name
    query_prompt = f"Provide a brief, general overview of the brand: {brand_name}."
    
    try:
        # 1. Hit GenAI (LLM) API (Feature 1)
        raw_llm_response = await llm_service.generate_response(query_prompt)
        # Unique ID for tracking this specific request/response
        response_id: str | None = None

        # Prepare initial response object
        initial_response = QueryResponse(
            brand_name=brand_name,
            raw_llm_response=raw_llm_response,
            status="Processing", # Indicate analysis is starting
            response_id=None # Will be set after MongoDB insert
        )
        
        # --- Step 2: Store Document in MongoDB ---
        # The document stored in MongoDB combines the query details and the LLM response
        full_document = QueryRecord(
            user_query=query_prompt, # Store the full prompt used
            response_data=initial_response,
            timestamp=datetime.datetime.now(datetime.timezone.utc),
            user_id="anonymous" 
        )
        
        try:
            # Insert the record and get the MongoDB ID
            response_id = await insert_query_record(full_document.model_dump(by_alias=True))
            initial_response.response_id = response_id # Set the ID on the object
        
        except ConnectionError as ce:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail=f"Database initialization failed (MongoDB): {ce}"
            )

        # --- Step 3: Trigger ES Indexing/Analysis (Feature 2 & 3 pipeline starts) ---
        # Run the analysis pipeline in the background using asyncio.create_task
        # This prevents the HTTP response from being blocked by the analysis process.
        asyncio.create_task(
            start_analysis_pipeline(response_id, brand_name, raw_llm_response)
        )
        
        # Return the immediate, accepted (202) response to the client
        # This tells the client "I got your request, here is the ID, processing is starting."
        return initial_response

    except HTTPException:
        # Re-raise explicit HTTP exceptions
        raise
    except Exception as e:
        print(f"An error occurred during LLM query or process start: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"LLM Query Failed: {str(e)}")


@router.get("/query/{response_id}", response_model=QueryDetails)
async def get_query_status(
    response_id: str = Path(..., description="The unique ID of the query generated by POST /query-brand.")
):
    """
    Feature 5 (Individual Query): Retrieves the status and final score for a specific single query.
    Uses response_id for precise lookup in MongoDB.
    """
    query_details = await get_query_details_by_id(response_id)
    
    if query_details is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Query ID '{response_id}' not found."
        )

    # MongoDB returns the 'response_data' field, which matches the QueryDetails Pydantic model
    return QueryDetails(**query_details)


@router.get("/metrics/aggregate/brand/{brand_name}", response_model=AggregateMetrics)
async def get_brand_metrics_aggregate(
    brand_name: str = Path(..., description="The brand name to retrieve aggregate metrics for.")
):
    """
    Feature 5 (Aggregate): Retrieves historical average metrics (PostgreSQL).
    """
    try:
        metrics = await get_brand_metrics(brand_name)
        
        if metrics['total_queries'] == 0:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"No historical queries found for brand '{brand_name}'."
            )
            
        return metrics
        
    except ConnectionError as ce:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"PostgreSQL connection pool not initialized: {ce}"
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Metrics retrieval failed: {e}")
